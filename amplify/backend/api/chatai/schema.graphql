# amplify/backend/api/chatai/schema.graphql

# ========== User ==========
type User
  @model
  @auth(rules: [{ allow: private }]) {
  id: ID!
  email: String!
  displayName: String!
  voiceInputSilenceTimeout: Int! @default(value: "3")
  language: String! @default(value: "ja")
  displayTheme: String! @default(value: "system")
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!

  # Relations
  teams: [TeamMember] @hasMany(indexName: "byUser", fields: ["id"])
  favoriteThemes: [FavoriteTheme] @hasMany(indexName: "byUser", fields: ["id"])
  notificationSettings: [NotificationSetting] @hasMany(indexName: "byUser", fields: ["id"])
}

# ========== Team ==========
type Team
  @model
  @auth(rules: [{ allow: private }]) {
  id: ID!
  name: String!
  createdBy: String!
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!

  # Relations
  members: [TeamMember] @hasMany(indexName: "byTeam", fields: ["id"])
}

type TeamMember
  @model
  @auth(rules: [{ allow: private }]) {
  id: ID!
  teamId: ID! @index(name: "byTeam", sortKeyFields: ["joinedAt"])
  userId: ID! @index(name: "byUser", sortKeyFields: ["joinedAt"])
  joinedAt: AWSDateTime!

  # Relations
  team: Team @belongsTo(fields: ["teamId"])
  user: User @belongsTo(fields: ["userId"])
}

# ========== Theme ==========
type Theme
  @model
  @auth(rules: [{ allow: private }]) {
  id: ID!
  name: String!
  fields: [ThemeField!]!
  notificationEnabled: Boolean! @default(value: "true")
  createdBy: String! @index(name: "byCreator", sortKeyFields: ["createdAt"])
  usageCount: Int! @default(value: "0")
  isDefault: Boolean! @default(value: "false")
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!

  # Relations
  favorites: [FavoriteTheme] @hasMany(indexName: "byTheme", fields: ["id"])
  sessions: [ChatSession] @hasMany(indexName: "byTheme", fields: ["id"])
  savedData: [SavedData] @hasMany(indexName: "byTheme", fields: ["id"])
}

type ThemeField {
  id: ID!
  name: String!
  type: FieldType!
  required: Boolean!
  options: [String!]
  order: Int!
}

enum FieldType {
  TEXT
  TEXTAREA
  DATE
  DATETIME
  NUMBER
  SELECT
}

type FavoriteTheme
  @model
  @auth(rules: [{ allow: private }]) {
  id: ID!
  userId: ID! @index(name: "byUser", sortKeyFields: ["addedAt"])
  themeId: ID! @index(name: "byTheme")
  addedAt: AWSDateTime!

  # Relations
  user: User @belongsTo(fields: ["userId"])
  theme: Theme @belongsTo(fields: ["themeId"])
}

# ========== Chat Session ==========
type ChatSession
  @model
  @auth(rules: [{ allow: private }]) {
  id: ID!
  userId: ID! @index(name: "byUser", sortKeyFields: ["updatedAt"])
  themeId: ID! @index(name: "byTheme", sortKeyFields: ["updatedAt"])
  title: String!
  titleLocked: Boolean! @default(value: "false")
  status: SessionStatus! @default(value: "ACTIVE")
  messageCount: Int! @default(value: "0")
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!

  # Relations
  messages: [ChatMessage] @hasMany(indexName: "bySession", fields: ["id"])
}

enum SessionStatus {
  ACTIVE
  COMPLETED
  DRAFT
}

type ChatMessage
  @model
  @auth(rules: [{ allow: private }]) {
  id: ID!
  sessionId: ID! @index(name: "bySession", sortKeyFields: ["timestamp"])
  role: MessageRole!
  content: String!
  images: [String!]
  isStreaming: Boolean @default(value: "false")
  timestamp: AWSDateTime!

  # Relations
  session: ChatSession @belongsTo(fields: ["sessionId"])
}

enum MessageRole {
  USER
  ASSISTANT
}

# ストリーミング用の一時データ
type StreamChunk
  @model
  @auth(rules: [{ allow: private }]) {
  id: ID!
  sessionId: ID! @index(name: "bySession", sortKeyFields: ["chunkIndex"])
  messageId: ID!
  chunkIndex: Int!
  content: String!
  isComplete: Boolean! @default(value: "false")
  timestamp: AWSDateTime!
}

# ========== Saved Data ==========
type SavedData
  @model
  @auth(rules: [{ allow: private }]) {
  id: ID!
  themeId: ID! @index(name: "byTheme", sortKeyFields: ["createdAt"])
  sessionId: ID @index(name: "bySession")
  title: String!
  content: AWSJSON!
  markdownContent: String!
  images: [String!]!
  createdBy: String! @index(name: "byCreator", sortKeyFields: ["createdAt"])
  isDeleted: Boolean! @default(value: "false")
  deletedAt: AWSDateTime
  deletedBy: String
  createdAt: AWSDateTime! @index(name: "byCreatedAt", sortKeyFields: ["id"])
  updatedAt: AWSDateTime!

  # Relations
  editHistory: [EditHistory] @hasMany(indexName: "byData", fields: ["id"])
}

type EditHistory
  @model
  @auth(rules: [{ allow: private }]) {
  id: ID!
  dataId: ID! @index(name: "byData", sortKeyFields: ["timestamp"])
  userId: String!
  action: EditAction!
  changes: AWSJSON!
  snapshot: AWSJSON!
  timestamp: AWSDateTime!
}

enum EditAction {
  CREATE
  UPDATE
  DELETE
}

# ========== Notification ==========
type Notification
  @model
  @auth(rules: [{ allow: private }]) {
  id: ID!
  userId: ID! @index(name: "byUser", sortKeyFields: ["createdAt"])
  type: NotificationType!
  title: String!
  message: String!
  relatedDataId: ID
  relatedTeamId: ID
  isRead: Boolean! @default(value: "false")
  createdAt: AWSDateTime!
  ttl: AWSTimestamp  # 30日後に自動削除
}

enum NotificationType {
  NEW_DATA
  DATA_UPDATED
  TEAM_INVITE
}

type NotificationSetting
  @model
  @auth(rules: [{ allow: private }]) {
  id: ID!
  userId: ID! @index(name: "byUser")
  targetType: NotificationTargetType!
  targetId: ID  # themeId or teamId
  enabled: Boolean!
  updatedAt: AWSDateTime!
}

enum NotificationTargetType {
  THEME
  TEAM
  EMAIL
}

# ========== Queries & Mutations (Custom) ==========

type Query {
  # 検索（DynamoDB Scan）
  searchSavedData(
    keyword: String!
    themeId: ID
    limit: Int
    nextToken: String
  ): SavedDataConnection @function(name: "searchDataHandler-${env}")
}

type SavedDataConnection {
  items: [SavedData!]!
  nextToken: String
  totalCount: Int
}

type Mutation {
  # AIチャット
  sendChatMessage(
    sessionId: ID!
    content: String!
    images: [String!]
  ): ChatMessage @function(name: "chatHandler-${env}")

  # データ保存
  saveDataFromSession(sessionId: ID!): SavedData
    @function(name: "dataProcessor-${env}")

  # 音声合成
  synthesizeSpeech(text: String!): SpeechResult
    @function(name: "pollyHandler-${env}")

  # 通知一括既読
  markAllNotificationsAsRead: Boolean
    @function(name: "notificationHandler-${env}")
}

type SpeechResult {
  audioUrl: String!
  expiresAt: AWSDateTime!
}

type Subscription {
  # AIレスポンスのストリーミング
  onStreamChunk(sessionId: ID!): StreamChunk
    @aws_subscribe(mutations: ["createStreamChunk"])

  # 新規メッセージ
  onNewMessage(sessionId: ID!): ChatMessage
    @aws_subscribe(mutations: ["createChatMessage"])

  # 通知
  onNewNotification(userId: ID!): Notification
    @aws_subscribe(mutations: ["createNotification"])
}
